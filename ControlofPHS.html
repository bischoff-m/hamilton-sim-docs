<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Manuel Kleinschmager">
<meta name="dcterms.date" content="2025-12-02">

<title>Control of Port-Hamiltonian Systems – Port-Hamiltonian Simulator</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Port-Hamiltonian Simulator</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./basics.html"> 
<span class="menu-text">Basics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./notation.html"> 
<span class="menu-text">Preliminaries</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./LinearPHS.html"> 
<span class="menu-text">Port-Hamiltonian Systems</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./ControlofPHS.html" aria-current="page"> 
<span class="menu-text">Control of Port-Hamiltonian Systems</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#control-of-port-hamiltonian-systems" id="toc-control-of-port-hamiltonian-systems" class="nav-link active" data-scroll-target="#control-of-port-hamiltonian-systems">Control of port-Hamiltonian systems</a>
  <ul class="collapse">
  <li><a href="#energy-casimir-method" id="toc-energy-casimir-method" class="nav-link" data-scroll-target="#energy-casimir-method">Energy-Casimir method</a></li>
  <li><a href="#dynamic-controller-systems" id="toc-dynamic-controller-systems" class="nav-link" data-scroll-target="#dynamic-controller-systems">Dynamic controller systems</a></li>
  <li><a href="#example-pid-controllers" id="toc-example-pid-controllers" class="nav-link" data-scroll-target="#example-pid-controllers">Example: PID controllers</a></li>
  <li><a href="#control-by-energy-routing" id="toc-control-by-energy-routing" class="nav-link" data-scroll-target="#control-by-energy-routing">Control by Energy-routing</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Control of Port-Hamiltonian Systems</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Manuel Kleinschmager </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><span class="math display">\[
\newcommand{\1}{1\hspace{-0,9ex}1}
\newcommand{\R}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Prob}{\mathbb{P}}
\newcommand{\cvar}{\text{CVaR}}
\newcommand{\var}{\text{VaR}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\T}{\mathbb{T}}
\]</span></p>
<section id="control-of-port-hamiltonian-systems" class="level2">
<h2 class="anchored" data-anchor-id="control-of-port-hamiltonian-systems">Control of port-Hamiltonian systems</h2>
<p>Consider an input-state-output port-Hamiltonian system <span class="math inline">\(\Sigma\)</span> without feedthrough terms. The simplest situation in stabilization is when the set-point <span class="math inline">\(x^\ast\in\mathcal{X}\)</span> is a strict minimum of the Hamiltonian <span class="math inline">\(H\)</span>. In this case, the pHS is passive, and thus we may directly apply the asymptotic stabilization theory of passive systems provided in Chapter 4 of <span class="citation" data-cites="AvdS2000l2Gain">Van der Schaft (<a href="#ref-AvdS2000l2Gain" role="doc-biblioref">2000</a>)</span>, by employing output feedback <span class="math inline">\(u=-Dy\)</span> with <span class="math inline">\(D=D^T\)</span> a positive definite matrix, and using the Hamiltonian <span class="math inline">\(H\)</span> as Lyapunov function.</p>
<section id="energy-casimir-method" class="level3">
<h3 class="anchored" data-anchor-id="energy-casimir-method">Energy-Casimir method</h3>
<p>The situation becomes different when the set-point <span class="math inline">\(x^\ast\)</span> is not a strict minimum of the Hamiltonian <span class="math inline">\(H\)</span>. A new twist is provided by the possible existence of Casimir functions. Assume one can find a Casimir function <span class="math inline">\(C\)</span> such that the modified Hamiltonian</p>
<p><span class="math display">\[
H_\text{mod}(x) := \Phi(H(x), C(x))
\]</span></p>
<p>for some map <span class="math inline">\(\Phi:\R^2 \to\R\)</span> has a strict minimum at the set-point <span class="math inline">\(x^\ast\)</span>. Then the system can be rewritten as the modified ISOPHS</p>
<p><span class="math display">\[\begin{align*}
\dot{x} &amp;= [J(x) - R(x)]\nabla H_\text{mod}(x) + g(x)u\\
y_\text{mod} &amp;= g^T(x) \nabla H_\text{mod}(x),
\end{align*}\]</span></p>
<p>which is passive w.r.t. the modified output <span class="math inline">\(y_\text{mod}\)</span>. Hence, asymptotic stabilization of <span class="math inline">\(x^\ast\)</span> may be achieved by feedback <span class="math inline">\(u=Dy_\text{mod}\)</span>, <span class="math inline">\(D&gt;0\)</span>, employing <span class="math inline">\(H_\text{mod}\)</span> as Lyapunov candidate function, provided a detectability condition is satisfied. The stability analysis method of finding Casimirs <span class="math inline">\(C_1,\ldots, C_r\)</span> such that a suitable function <span class="math inline">\(\Phi(H,C_1,\ldots, C_r)\)</span> of the energy <span class="math inline">\(H\)</span> and the Casimirs has a strict minimum at the equilibrium under consideration is called the <span style="color: red;">Energy-Casimir method</span>.</p>
</section>
<section id="dynamic-controller-systems" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-controller-systems">Dynamic controller systems</h3>
<p>Next, suppose that <span class="math inline">\(H\)</span> does not have a strict minimum at <span class="math inline">\(x^\ast\)</span>, and that no useful Casimirs <span class="math inline">\(C\)</span> can be found for direct application of the Energy-Casimir method. In this case, we will take recourse to dynamical controller systems that are also in port-Hamiltonian form, in order to generate Casimirs for the closed-loop system. Any power-conserving interconnection of pHS is again pHS. In particular, the interconnection of the plant pHS <span class="math inline">\(\Sigma\)</span> with a controller pHS <span class="math inline">\(\Sigma_c\)</span></p>
<p><span class="math display">\[\begin{align*}
\dot{\xi} &amp;= [J_c(\xi) - R_c(\xi)]\nabla H_c(\xi) + g_c(\xi) u_c,\quad\xi\in\mathcal{X}_c, u_c\in\R^m\\
y_c &amp;= g_c^T(\xi)\nabla H_c(\xi)
\end{align*}\]</span></p>
<p>with <span class="math inline">\(J_c(\xi) = -J_c^T(\xi)\)</span>, <span class="math inline">\(R_c(\xi) = R_c^T(\xi)\geq 0\)</span>, via the standard negative feedback interconnection</p>
<p><span class="math display">\[\begin{align*}
u &amp;= -y_c + v\\
u_c &amp;= y + v_c
\end{align*}\]</span></p>
<p>where <span class="math inline">\(v,v_c\)</span> are external input signals, results in the closed-loop system</p>
<p><span class="math display">\[\begin{align*}
\left[\begin{matrix}
\dot{x}\\
\dot{\xi}
\end{matrix}\right] &amp;= \left(\underbrace{\left[\begin{matrix}
J(x) &amp; -g(x)g_c^T(\xi)\\
g_c(\xi)g^T(x) &amp; J_c(\xi)
\end{matrix}\right]}_{J_{cl}(x,\xi)} - \underbrace{\left[\begin{matrix}
R(x) &amp; 0\\
0 &amp; R_c(\xi)
\end{matrix}\right]}_{R_{cl}(x,\xi)}\right)\left[\begin{matrix}
\frac{\partial H}{\partial x}(x) \\
\frac{\partial H_c}{\partial\xi}(\xi)
\end{matrix}\right] + \left[\begin{matrix}
g(x) &amp; 0\\
0 &amp; g_c(\xi)
\end{matrix}\right]\left[\begin{matrix}
v\\
v_c
\end{matrix}\right]\\
\left[\begin{matrix}
y\\
y_c
\end{matrix}\right] &amp;= \left[\begin{matrix}
g^T(x) &amp; 0\\
0 &amp; g^T_c(\xi)
\end{matrix}\right]\left[\begin{matrix}
\frac{\partial H}{\partial x}(x) \\
\frac{\partial H_c}{\partial\xi}(\xi)
\end{matrix}\right].
\end{align*}\]</span></p>
<p>This is again an ISOPHS, with state space <span class="math inline">\(\mathcal{X}\times\mathcal{X}_c\)</span>, Hamiltonian <span class="math inline">\(H(x) + H_c(x)\)</span>, interconnection structure matrix <span class="math inline">\(J_{cl}(x, \xi)\)</span>, resistive structure matrix <span class="math inline">\(R_{cl}(x,\xi)\)</span>, inputs <span class="math inline">\((v,v_c)\)</span> and outputs <span class="math inline">\((y,y_c)\)</span>.</p>
</section>
<section id="example-pid-controllers" class="level3">
<h3 class="anchored" data-anchor-id="example-pid-controllers">Example: PID controllers</h3>
<p>Consider the standard Proportional-Integral-Derivative (PID) controller</p>
<p><span class="math display">\[
y_c = k_Pu_c + k_I \int u_c dt + k_D\dot{u}_c
\]</span></p>
<p>for certain positive constants <span class="math inline">\(k_P, k_I, k_D\)</span>. Rewriting the above as</p>
<p><span class="math display">\[
k_D\dot{u}_c = -k_Pu_c - k_I\int u_cdt + y_c
\]</span></p>
<p>and defining <span class="math inline">\(\xi = \int u_cdt\)</span> (or equivalently <span class="math inline">\(\dot{\xi} = u_c\)</span>) and <span class="math inline">\(\eta=k_Du_c\)</span>, the PID-controller can be formulated as the linear ISOPHS</p>
<p><span class="math display">\[\begin{align*}
\left[\begin{matrix}
\dot{\xi}\\
\dot{\eta}
\end{matrix}\right] &amp;= \left[\begin{matrix}
0 &amp; 1\\
-1 &amp; -k_P
\end{matrix}\right]\left[\begin{matrix}
k_I\xi\\
\frac{\eta}{k_D}
\end{matrix}\right] + \left[\begin{matrix}
0\\
1
\end{matrix}\right]y_c\\
u_c &amp;= \left[\begin{matrix}
0 &amp; 1
\end{matrix}\right]\left[\begin{matrix}
k_I\xi\\
\frac{\eta}{k_D}
\end{matrix}\right]
\end{align*}\]</span></p>
<p>with Hamiltonian <span class="math inline">\(H_c(\xi,\eta) = \frac{1}{2}k_I\xi^2 + \frac{1}{2k_D}\eta^2\)</span>. Considering any plant ISOPHS <span class="math inline">\(\Sigma\)</span>, the closed-loop system arising from standard feedback <span class="math inline">\(u=-y_c\)</span>, <span class="math inline">\(u_c = y\)</span> with the PID controller is given by the pHDAE</p>
<p><span class="math display">\[\begin{align*}
\dot{x} &amp;= [J(x) - R(x)]\nabla H(x) + g(x)u\\
\left[\begin{matrix}
\dot{\xi}\\
\dot{\eta}
\end{matrix}\right] &amp;= \left[\begin{matrix}
0 &amp; 1\\
-1 &amp; -k_P
\end{matrix}\right]\left[\begin{matrix}
k_I\xi\\
\frac{\eta}{k_D}
\end{matrix}\right] - \left[\begin{matrix}
0\\
1
\end{matrix}\right]u\\
0 &amp;= g^T(x)\nabla H(x) - \left[\begin{matrix}
0 &amp; 1
\end{matrix}\right]\left[\begin{matrix}
k_I\xi\\
\frac{\eta}{k_D}
\end{matrix}\right]
\end{align*}\]</span></p>
</section>
<section id="control-by-energy-routing" class="level3">
<h3 class="anchored" data-anchor-id="control-by-energy-routing">Control by Energy-routing</h3>
<p>Consider the problem of energy-transfer. Consider two pHS <span class="math inline">\(\Sigma_i\)</span> (without internal dissipation) in input-state-output form</p>
<p><span class="math display">\[\begin{align*}
\dot{x}_i &amp;= J_i(x_i)\frac{\partial H_i}{\partial x_i}(x_i) + g_i(x_i)u_i,\quad u_i\in\R^m,\\
y_i &amp;= g_i^T(x_i) \frac{\partial H_i}{\partial x_i}(x_i),
\end{align*}\]</span></p>
<p><span class="math inline">\(i=1,2\)</span> both satisfying the power balance</p>
<p><span class="math display">\[
\dot{H}_i(x_i) = y_i^Tu_i.
\]</span></p>
<p>Suppose now that we want to transfer energy from system <span class="math inline">\(\Sigma_1\)</span> to <span class="math inline">\(\Sigma_2\)</span>, while keeping the total energy <span class="math inline">\(H_1+H_2\)</span> constant. This can be done by using the following output feedback</p>
<p><span class="math display">\[\begin{align*}
\left[\begin{matrix}
u_1\\
u_2
\end{matrix}\right] &amp;= \left[\begin{matrix}
0 &amp; -y_1y_2^T\\
y_2y_1 &amp; 0
\end{matrix}\right]\left[\begin{matrix}
y_1\\
y_2
\end{matrix}\right]
\end{align*}\]</span></p>
<p>which due to its skew-symmetry property, is power preserving. Hence, the closed-loop system composed of <span class="math inline">\(\Sigma_1\)</span> and <span class="math inline">\(\Sigma_2\)</span> is energy preservingm that is <span class="math inline">\(\dot{H}_1 + \dot{H}_2 = 0\)</span>. However, if we consider the individual energies then we notice that <span class="math display">\[\begin{align*}
\dot{H}_1(x) = -y_1^Ty_1y_2^Ty_2 = -\|y_1\|^2\|y_2\|^2\geq 0,
\end{align*}\]</span> implying that <span class="math inline">\(H_1\)</span> is decreasing as long as <span class="math inline">\(\|y_1\|\)</span> and <span class="math inline">\(\|y_2\|\)</span> are different from <span class="math inline">\(0\)</span>. Conversely, as expected since the total energy is constant,</p>
<p><span class="math display">\[\begin{align*}
\dot{H}_2(x) = y_2^Ty_2y_1^Ty_1 = \|y_2\|^2\|y_1\|^2\leq 0,
\end{align*}\]</span></p>
<p>implying that <span class="math inline">\(H_2\)</span> is increasing at the same rate. In particular, if <span class="math inline">\(H_1\)</span> has a minimum at the zero equilibrium, and <span class="math inline">\(\Sigma_1\)</span> is zero-state detectable, then all the energy <span class="math inline">\(H_1\)</span> of <span class="math inline">\(\Sigma_1\)</span> will be transferred to <span class="math inline">\(\Sigma_2\)</span>, as long as <span class="math inline">\(\|y_2\|\)</span> is not zero. If there is internal energy dissipation in <span class="math inline">\(\Sigma_1\)</span> and/or <span class="math inline">\(\Sigma_2\)</span>, then this energy transfer mechanism still works. However, the fact that <span class="math inline">\(H_2\)</span> grows or not will depend on the balance between the energy delivered by <span class="math inline">\(\Sigma_1\)</span> to <span class="math inline">\(\Sigma_2\)</span> and the internal loss of energy in <span class="math inline">\(\Sigma_2\)</span> due to dissipation. We conclude that this particular scheme of power-conserving energy transfer is accomplished by a skew-symmetric output feedback, which is modulated by the values of the output vectors of both systems. A related scenario for energy-routing is the case where the interconnection matrix <span class="math inline">\(J\)</span> is depending on the control <span class="math inline">\(u\)</span>. Such a case, for example, occurs in the control of power converters, where different switch positions lead to different circuit topologies, and where the duty ratio’s may be taken as control variables, leading to <span class="math inline">\(J(u)\)</span>. Especially in case external sources and sinks are present, this allows for a control of the power flow through the system in such a manner that certain crucial variables are kept close to their desired values.</p>



</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-AvdS2000l2Gain" class="csl-entry" role="listitem">
Van der Schaft, Arjan. 2000. <em>L2-Gain and Passivity Techniques in Nonlinear Control</em>. Springer.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/bischoff-m\.github\.io\/hamilton-sim-docs\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>